# Vue3新特性

#### 总结

1 . 数据响应式 原理重新实现 ( ES6 的 proxy 替代了 ES5 的 Object.defineProperty)

- 解决了对象、数组更新后的检测, 大大优化了响应式监听的性能
- 原来检测对象属性的变化, 需要一个个对属性递归监听, proxy 可以直接对整个对象劫持

2 . 虚拟 DOM - 新算法 (更快 更小)

3 . 提供了 composition api, 可以更好的逻辑复用

4 . template 模板可以有多个根元素

5 . 源码用 typescript 重写, 有更好的 类型推导 (类型检测更为严格, 更稳定)



#### `Composition API`

- `compositionAPI` 是基于 **逻辑功能** 组织代码的, 一个功能 api 相关放到一起
- 即使项目大了, 功能多了, 也能快速定位功能相关的 api
- 大大的提升了 `代码可读性` 和 `可维护性`



### `setup` 函数

**`composition`** 的使用, 需要配置一个 **`setup`** 函数

- `setup` 函数是一个新的组件选项, 作为组件中 `compositionAPI` 的起点
- 从生命周期角度来看, `setup` 会在 `beforeCreate` 钩子函数之前执行
- 在 `template` 模版中需要使用的数据和函数，需要在 `setup` 返回

<script>
export default {
  setup () {
    console.log('setup执行了')
    console.log(this) // undefined
    // 定义数据和函数
    const msg = 'hi vue3'
    const say = () => {
      console.log(msg)
    }
    return { msg , say}
},
  beforeCreate() {
    console.log('beforeCreate执行了')
    console.log(this)
  }
}
</script>

**`template`**

<template>
  <div>
    <h1 @click="say()">{{msg}}</h1>
  </div>
</template>



### `reactive` 函数

**`setup`** 中默认普通的数据不是[响应式](https://so.csdn.net/so/search?q=响应式&spm=1001.2101.3001.7020)的, 需要用 **`reactive`** 函数

- **`setup`** 需要有返回值, 只有返回的值才能在模板中使用
- 通常是用来定义响应式 **对象数据**
- `reactive`函数需要按需导入才能使用
  - **语法 : `import { reactive } from 'vue'`**



setup () 中

```javascript
 setup () {
    const obj = reactive({
      name: 'zs',
      age: 18
    })

return {
  obj
}
```


template 模板中

<template>
  <div>{{ obj.name }}</div>
  <div>{{ obj.age }}</div>
</template>